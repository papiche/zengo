schema {
  query: query_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""Table of accounts."""
type account {
  """An object relationship"""
  block: block!
  created_at: timestamptz!

  """Block number where account was created."""
  created_on: Int!

  """
  A computed field, executes function "has_identity"
  """
  has_identity: Boolean

  """An object relationship"""
  identity: identity
  killed_at: timestamptz

  """Block number where account was killed."""
  killed_on: Int

  """Pubkey of the account."""
  pubkey: String!

  """An array relationship"""
  transactions_issued(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_issued_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """An array relationship"""
  transactions_received(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_received_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!
}

"""
aggregated selection of "account"
"""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"""
aggregate fields of "account"
"""
type account_aggregate_fields {
  avg: account_avg_fields
  count(columns: [account_select_column!], distinct: Boolean): Int!
  max: account_max_fields
  min: account_min_fields
  stddev: account_stddev_fields
  stddev_pop: account_stddev_pop_fields
  stddev_samp: account_stddev_samp_fields
  sum: account_sum_fields
  var_pop: account_var_pop_fields
  var_samp: account_var_samp_fields
  variance: account_variance_fields
}

"""aggregate avg on columns"""
type account_avg_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""
Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
"""
input account_bool_exp {
  _and: [account_bool_exp!]
  _not: account_bool_exp
  _or: [account_bool_exp!]
  block: block_bool_exp
  created_at: timestamptz_comparison_exp
  created_on: Int_comparison_exp
  has_identity: Boolean_comparison_exp
  identity: identity_bool_exp
  killed_at: timestamptz_comparison_exp
  killed_on: Int_comparison_exp
  pubkey: String_comparison_exp
  transactions_issued: transaction_bool_exp
  transactions_issued_aggregate: transaction_aggregate_bool_exp
  transactions_received: transaction_bool_exp
  transactions_received_aggregate: transaction_aggregate_bool_exp
}

"""aggregate max on columns"""
type account_max_fields {
  created_at: timestamptz

  """Block number where account was created."""
  created_on: Int
  killed_at: timestamptz

  """Block number where account was killed."""
  killed_on: Int

  """Pubkey of the account."""
  pubkey: String
}

"""aggregate min on columns"""
type account_min_fields {
  created_at: timestamptz

  """Block number where account was created."""
  created_on: Int
  killed_at: timestamptz

  """Block number where account was killed."""
  killed_on: Int

  """Pubkey of the account."""
  pubkey: String
}

"""Ordering options when selecting data from "account"."""
input account_order_by {
  block: block_order_by
  created_at: order_by
  created_on: order_by
  has_identity: order_by
  identity: identity_order_by
  killed_at: order_by
  killed_on: order_by
  pubkey: order_by
  transactions_issued_aggregate: transaction_aggregate_order_by
  transactions_received_aggregate: transaction_aggregate_order_by
}

"""
select columns of table "account"
"""
enum account_select_column {
  """column name"""
  created_at

  """column name"""
  created_on

  """column name"""
  killed_at

  """column name"""
  killed_on

  """column name"""
  pubkey
}

"""aggregate stddev on columns"""
type account_stddev_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""aggregate stddev_pop on columns"""
type account_stddev_pop_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""aggregate stddev_samp on columns"""
type account_stddev_samp_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""
Streaming cursor of the table "account"
"""
input account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_stream_cursor_value_input {
  created_at: timestamptz

  """Block number where account was created."""
  created_on: Int
  killed_at: timestamptz

  """Block number where account was killed."""
  killed_on: Int

  """Pubkey of the account."""
  pubkey: String
}

"""aggregate sum on columns"""
type account_sum_fields {
  """Block number where account was created."""
  created_on: Int

  """Block number where account was killed."""
  killed_on: Int
}

"""aggregate var_pop on columns"""
type account_var_pop_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""aggregate var_samp on columns"""
type account_var_samp_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""aggregate variance on columns"""
type account_variance_fields {
  """Block number where account was created."""
  created_on: Float

  """Block number where account was killed."""
  killed_on: Float
}

"""Table of blocks."""
type block {
  created_at: timestamp!

  """
  Data contains `extrinsics` and `events` of the block. Exemple for querying
  specific data: `data(path: "extrinsics[0].isSigned")`.
  """
  data(
    """JSON select path"""
    path: String
  ): jsonb
  hash: String!

  """Number of the block in substrate."""
  number: Int!
}

"""
aggregated selection of "block"
"""
type block_aggregate {
  aggregate: block_aggregate_fields
  nodes: [block!]!
}

"""
aggregate fields of "block"
"""
type block_aggregate_fields {
  avg: block_avg_fields
  count(columns: [block_select_column!], distinct: Boolean): Int!
  max: block_max_fields
  min: block_min_fields
  stddev: block_stddev_fields
  stddev_pop: block_stddev_pop_fields
  stddev_samp: block_stddev_samp_fields
  sum: block_sum_fields
  var_pop: block_var_pop_fields
  var_samp: block_var_samp_fields
  variance: block_variance_fields
}

"""aggregate avg on columns"""
type block_avg_fields {
  """Number of the block in substrate."""
  number: Float
}

"""
Boolean expression to filter rows from the table "block". All fields are combined with a logical 'AND'.
"""
input block_bool_exp {
  _and: [block_bool_exp!]
  _not: block_bool_exp
  _or: [block_bool_exp!]
  created_at: timestamp_comparison_exp
  data: jsonb_comparison_exp
  hash: String_comparison_exp
  number: Int_comparison_exp
}

"""aggregate max on columns"""
type block_max_fields {
  created_at: timestamp
  hash: String

  """Number of the block in substrate."""
  number: Int
}

"""aggregate min on columns"""
type block_min_fields {
  created_at: timestamp
  hash: String

  """Number of the block in substrate."""
  number: Int
}

"""Ordering options when selecting data from "block"."""
input block_order_by {
  created_at: order_by
  data: order_by
  hash: order_by
  number: order_by
}

"""
select columns of table "block"
"""
enum block_select_column {
  """column name"""
  created_at

  """column name"""
  data

  """column name"""
  hash

  """column name"""
  number
}

"""aggregate stddev on columns"""
type block_stddev_fields {
  """Number of the block in substrate."""
  number: Float
}

"""aggregate stddev_pop on columns"""
type block_stddev_pop_fields {
  """Number of the block in substrate."""
  number: Float
}

"""aggregate stddev_samp on columns"""
type block_stddev_samp_fields {
  """Number of the block in substrate."""
  number: Float
}

"""
Streaming cursor of the table "block"
"""
input block_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: block_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input block_stream_cursor_value_input {
  created_at: timestamp

  """
  Data contains `extrinsics` and `events` of the block. Exemple for querying
  specific data: `data(path: "extrinsics[0].isSigned")`.
  """
  data: jsonb
  hash: String

  """Number of the block in substrate."""
  number: Int
}

"""aggregate sum on columns"""
type block_sum_fields {
  """Number of the block in substrate."""
  number: Int
}

"""aggregate var_pop on columns"""
type block_var_pop_fields {
  """Number of the block in substrate."""
  number: Float
}

"""aggregate var_samp on columns"""
type block_var_samp_fields {
  """Number of the block in substrate."""
  number: Float
}

"""aggregate variance on columns"""
type block_variance_fields {
  """Number of the block in substrate."""
  number: Float
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""Table of certifications."""
type certification {
  created_at: timestamptz!

  """Block number where certification was created."""
  created_on: Int!

  """An object relationship"""
  created_on_block: block!

  """An object relationship"""
  issuer: identity!

  """Index of issuer"""
  issuer_index: Int!

  """An object relationship"""
  receiver: identity!

  """Index of receiver"""
  receiver_index: Int!
}

"""
aggregated selection of "certification"
"""
type certification_aggregate {
  aggregate: certification_aggregate_fields
  nodes: [certification!]!
}

input certification_aggregate_bool_exp {
  count: certification_aggregate_bool_exp_count
}

input certification_aggregate_bool_exp_count {
  arguments: [certification_select_column!]
  distinct: Boolean
  filter: certification_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "certification"
"""
type certification_aggregate_fields {
  avg: certification_avg_fields
  count(columns: [certification_select_column!], distinct: Boolean): Int!
  max: certification_max_fields
  min: certification_min_fields
  stddev: certification_stddev_fields
  stddev_pop: certification_stddev_pop_fields
  stddev_samp: certification_stddev_samp_fields
  sum: certification_sum_fields
  var_pop: certification_var_pop_fields
  var_samp: certification_var_samp_fields
  variance: certification_variance_fields
}

"""
order by aggregate values of table "certification"
"""
input certification_aggregate_order_by {
  avg: certification_avg_order_by
  count: order_by
  max: certification_max_order_by
  min: certification_min_order_by
  stddev: certification_stddev_order_by
  stddev_pop: certification_stddev_pop_order_by
  stddev_samp: certification_stddev_samp_order_by
  sum: certification_sum_order_by
  var_pop: certification_var_pop_order_by
  var_samp: certification_var_samp_order_by
  variance: certification_variance_order_by
}

"""aggregate avg on columns"""
type certification_avg_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by avg() on columns of table "certification"
"""
input certification_avg_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""
Boolean expression to filter rows from the table "certification". All fields are combined with a logical 'AND'.
"""
input certification_bool_exp {
  _and: [certification_bool_exp!]
  _not: certification_bool_exp
  _or: [certification_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_on: Int_comparison_exp
  created_on_block: block_bool_exp
  issuer: identity_bool_exp
  issuer_index: Int_comparison_exp
  receiver: identity_bool_exp
  receiver_index: Int_comparison_exp
}

"""aggregate max on columns"""
type certification_max_fields {
  created_at: timestamptz

  """Block number where certification was created."""
  created_on: Int

  """Index of issuer"""
  issuer_index: Int

  """Index of receiver"""
  receiver_index: Int
}

"""
order by max() on columns of table "certification"
"""
input certification_max_order_by {
  created_at: order_by

  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate min on columns"""
type certification_min_fields {
  created_at: timestamptz

  """Block number where certification was created."""
  created_on: Int

  """Index of issuer"""
  issuer_index: Int

  """Index of receiver"""
  receiver_index: Int
}

"""
order by min() on columns of table "certification"
"""
input certification_min_order_by {
  created_at: order_by

  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""Ordering options when selecting data from "certification"."""
input certification_order_by {
  created_at: order_by
  created_on: order_by
  created_on_block: block_order_by
  issuer: identity_order_by
  issuer_index: order_by
  receiver: identity_order_by
  receiver_index: order_by
}

"""
select columns of table "certification"
"""
enum certification_select_column {
  """column name"""
  created_at

  """column name"""
  created_on

  """column name"""
  issuer_index

  """column name"""
  receiver_index
}

"""aggregate stddev on columns"""
type certification_stddev_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by stddev() on columns of table "certification"
"""
input certification_stddev_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate stddev_pop on columns"""
type certification_stddev_pop_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by stddev_pop() on columns of table "certification"
"""
input certification_stddev_pop_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate stddev_samp on columns"""
type certification_stddev_samp_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by stddev_samp() on columns of table "certification"
"""
input certification_stddev_samp_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""
Streaming cursor of the table "certification"
"""
input certification_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: certification_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input certification_stream_cursor_value_input {
  created_at: timestamptz

  """Block number where certification was created."""
  created_on: Int

  """Index of issuer"""
  issuer_index: Int

  """Index of receiver"""
  receiver_index: Int
}

"""aggregate sum on columns"""
type certification_sum_fields {
  """Block number where certification was created."""
  created_on: Int

  """Index of issuer"""
  issuer_index: Int

  """Index of receiver"""
  receiver_index: Int
}

"""
order by sum() on columns of table "certification"
"""
input certification_sum_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate var_pop on columns"""
type certification_var_pop_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by var_pop() on columns of table "certification"
"""
input certification_var_pop_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate var_samp on columns"""
type certification_var_samp_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by var_samp() on columns of table "certification"
"""
input certification_var_samp_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""aggregate variance on columns"""
type certification_variance_fields {
  """Block number where certification was created."""
  created_on: Float

  """Index of issuer"""
  issuer_index: Float

  """Index of receiver"""
  receiver_index: Float
}

"""
order by variance() on columns of table "certification"
"""
input certification_variance_order_by {
  """Block number where certification was created."""
  created_on: order_by

  """Index of issuer"""
  issuer_index: order_by

  """Index of receiver"""
  receiver_index: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""Table of identities."""
type identity {
  """An object relationship"""
  account: account

  """An array relationship"""
  cert_issued(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): [certification!]!

  """An aggregate relationship"""
  cert_issued_aggregate(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): certification_aggregate!

  """An array relationship"""
  cert_received(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): [certification!]!

  """An aggregate relationship"""
  cert_received_aggregate(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): certification_aggregate!
  confirmed_at: timestamptz

  """Block number where identity was confirmed."""
  confirmed_on: Int

  """An object relationship"""
  confirmed_on_block: block

  """Block number where identity was created."""
  created_on: Int

  """An object relationship"""
  created_on_block: block
  index: Int!

  """Name of the identity."""
  name: String

  """Pubkey of the account associated to this identity."""
  pubkey: String!
  revoked_at: timestamptz

  """Block number where identity was revoked."""
  revoked_on: Int

  """An object relationship"""
  revoked_on_block: block
  validated_at: timestamptz

  """Block number where identity was validated."""
  validated_on: Int

  """An object relationship"""
  validated_on_block: block
}

"""
aggregated selection of "identity"
"""
type identity_aggregate {
  aggregate: identity_aggregate_fields
  nodes: [identity!]!
}

"""
aggregate fields of "identity"
"""
type identity_aggregate_fields {
  avg: identity_avg_fields
  count(columns: [identity_select_column!], distinct: Boolean): Int!
  max: identity_max_fields
  min: identity_min_fields
  stddev: identity_stddev_fields
  stddev_pop: identity_stddev_pop_fields
  stddev_samp: identity_stddev_samp_fields
  sum: identity_sum_fields
  var_pop: identity_var_pop_fields
  var_samp: identity_var_samp_fields
  variance: identity_variance_fields
}

"""aggregate avg on columns"""
type identity_avg_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""
Boolean expression to filter rows from the table "identity". All fields are combined with a logical 'AND'.
"""
input identity_bool_exp {
  _and: [identity_bool_exp!]
  _not: identity_bool_exp
  _or: [identity_bool_exp!]
  account: account_bool_exp
  cert_issued: certification_bool_exp
  cert_issued_aggregate: certification_aggregate_bool_exp
  cert_received: certification_bool_exp
  cert_received_aggregate: certification_aggregate_bool_exp
  confirmed_at: timestamptz_comparison_exp
  confirmed_on: Int_comparison_exp
  confirmed_on_block: block_bool_exp
  created_on: Int_comparison_exp
  created_on_block: block_bool_exp
  index: Int_comparison_exp
  name: String_comparison_exp
  pubkey: String_comparison_exp
  revoked_at: timestamptz_comparison_exp
  revoked_on: Int_comparison_exp
  revoked_on_block: block_bool_exp
  validated_at: timestamptz_comparison_exp
  validated_on: Int_comparison_exp
  validated_on_block: block_bool_exp
}

"""aggregate max on columns"""
type identity_max_fields {
  confirmed_at: timestamptz

  """Block number where identity was confirmed."""
  confirmed_on: Int

  """Block number where identity was created."""
  created_on: Int
  index: Int

  """Name of the identity."""
  name: String

  """Pubkey of the account associated to this identity."""
  pubkey: String
  revoked_at: timestamptz

  """Block number where identity was revoked."""
  revoked_on: Int
  validated_at: timestamptz

  """Block number where identity was validated."""
  validated_on: Int
}

"""aggregate min on columns"""
type identity_min_fields {
  confirmed_at: timestamptz

  """Block number where identity was confirmed."""
  confirmed_on: Int

  """Block number where identity was created."""
  created_on: Int
  index: Int

  """Name of the identity."""
  name: String

  """Pubkey of the account associated to this identity."""
  pubkey: String
  revoked_at: timestamptz

  """Block number where identity was revoked."""
  revoked_on: Int
  validated_at: timestamptz

  """Block number where identity was validated."""
  validated_on: Int
}

"""Ordering options when selecting data from "identity"."""
input identity_order_by {
  account: account_order_by
  cert_issued_aggregate: certification_aggregate_order_by
  cert_received_aggregate: certification_aggregate_order_by
  confirmed_at: order_by
  confirmed_on: order_by
  confirmed_on_block: block_order_by
  created_on: order_by
  created_on_block: block_order_by
  index: order_by
  name: order_by
  pubkey: order_by
  revoked_at: order_by
  revoked_on: order_by
  revoked_on_block: block_order_by
  validated_at: order_by
  validated_on: order_by
  validated_on_block: block_order_by
}

"""
select columns of table "identity"
"""
enum identity_select_column {
  """column name"""
  confirmed_at

  """column name"""
  confirmed_on

  """column name"""
  created_on

  """column name"""
  index

  """column name"""
  name

  """column name"""
  pubkey

  """column name"""
  revoked_at

  """column name"""
  revoked_on

  """column name"""
  validated_at

  """column name"""
  validated_on
}

"""aggregate stddev on columns"""
type identity_stddev_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""aggregate stddev_pop on columns"""
type identity_stddev_pop_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""aggregate stddev_samp on columns"""
type identity_stddev_samp_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""
Streaming cursor of the table "identity"
"""
input identity_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: identity_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input identity_stream_cursor_value_input {
  confirmed_at: timestamptz

  """Block number where identity was confirmed."""
  confirmed_on: Int

  """Block number where identity was created."""
  created_on: Int
  index: Int

  """Name of the identity."""
  name: String

  """Pubkey of the account associated to this identity."""
  pubkey: String
  revoked_at: timestamptz

  """Block number where identity was revoked."""
  revoked_on: Int
  validated_at: timestamptz

  """Block number where identity was validated."""
  validated_on: Int
}

"""aggregate sum on columns"""
type identity_sum_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Int

  """Block number where identity was created."""
  created_on: Int
  index: Int

  """Block number where identity was revoked."""
  revoked_on: Int

  """Block number where identity was validated."""
  validated_on: Int
}

"""aggregate var_pop on columns"""
type identity_var_pop_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""aggregate var_samp on columns"""
type identity_var_samp_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""aggregate variance on columns"""
type identity_variance_fields {
  """Block number where identity was confirmed."""
  confirmed_on: Float

  """Block number where identity was created."""
  created_on: Float
  index: Float

  """Block number where identity was revoked."""
  revoked_on: Float

  """Block number where identity was validated."""
  validated_on: Float
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""Table of key/value parameters."""
type parameters {
  key: String!
  value(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
Boolean expression to filter rows from the table "parameters". All fields are combined with a logical 'AND'.
"""
input parameters_bool_exp {
  _and: [parameters_bool_exp!]
  _not: parameters_bool_exp
  _or: [parameters_bool_exp!]
  key: String_comparison_exp
  value: jsonb_comparison_exp
}

"""Ordering options when selecting data from "parameters"."""
input parameters_order_by {
  key: order_by
  value: order_by
}

"""
select columns of table "parameters"
"""
enum parameters_select_column {
  """column name"""
  key

  """column name"""
  value
}

"""
Streaming cursor of the table "parameters"
"""
input parameters_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: parameters_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input parameters_stream_cursor_value_input {
  key: String
  value: jsonb
}

type query_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(
    """Pubkey of the account."""
    pubkey: String!
  ): account

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(
    """Number of the block in substrate."""
    number: Int!
  ): block

  """
  fetch data from the table: "certification"
  """
  certification(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): [certification!]!

  """
  fetch aggregated fields from the table: "certification"
  """
  certification_aggregate(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): certification_aggregate!

  """fetch data from the table: "certification" using primary key columns"""
  certification_by_pk(
    """Block number where certification was created."""
    created_on: Int!

    """Index of issuer"""
    issuer_index: Int!

    """Index of receiver"""
    receiver_index: Int!
  ): certification

  """
  fetch data from the table: "identity"
  """
  identity(
    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): [identity!]!

  """
  fetch aggregated fields from the table: "identity"
  """
  identity_aggregate(
    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): identity_aggregate!

  """fetch data from the table: "identity" using primary key columns"""
  identity_by_pk(index: Int!): identity

  """
  fetch data from the table: "parameters"
  """
  parameters(
    """distinct select on columns"""
    distinct_on: [parameters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parameters_order_by!]

    """filter the rows returned"""
    where: parameters_bool_exp
  ): [parameters!]!

  """fetch data from the table: "parameters" using primary key columns"""
  parameters_by_pk(key: String!): parameters

  """
  execute function "search_identity" which returns "identity"
  """
  search_identity(
    """
    input parameters for function "search_identity"
    """
    args: search_identity_args!

    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): [identity!]!

  """
  execute function "search_identity" and query aggregates on result of table type "identity"
  """
  search_identity_aggregate(
    """
    input parameters for function "search_identity_aggregate"
    """
    args: search_identity_args!

    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): identity_aggregate!

  """
  fetch data from the table: "smith"
  """
  smith(
    """distinct select on columns"""
    distinct_on: [smith_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_order_by!]

    """filter the rows returned"""
    where: smith_bool_exp
  ): [smith!]!

  """
  fetch aggregated fields from the table: "smith"
  """
  smith_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_order_by!]

    """filter the rows returned"""
    where: smith_bool_exp
  ): smith_aggregate!

  """fetch data from the table: "smith" using primary key columns"""
  smith_by_pk(idty_index: Int!): smith

  """
  fetch data from the table: "smith_cert"
  """
  smith_cert(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): [smith_cert!]!

  """
  fetch aggregated fields from the table: "smith_cert"
  """
  smith_cert_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): smith_cert_aggregate!

  """fetch data from the table: "smith_cert" using primary key columns"""
  smith_cert_by_pk(created_on: Int!, issuer_index: Int!, receiver_index: Int!): smith_cert

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(
    """
    Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
    """
    id: Int!
  ): transaction

  """
  execute function "transaction_timeserie" which returns "transaction_timeserie_tmp"
  """
  transaction_timeserie(
    """
    input parameters for function "transaction_timeserie"
    """
    args: transaction_timeserie_args!

    """distinct select on columns"""
    distinct_on: [transaction_timeserie_tmp_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_timeserie_tmp_order_by!]

    """filter the rows returned"""
    where: transaction_timeserie_tmp_bool_exp
  ): [transaction_timeserie_tmp!]!

  """
  fetch data from the table: "transaction_timeserie_tmp"
  """
  transaction_timeserie_tmp(
    """distinct select on columns"""
    distinct_on: [transaction_timeserie_tmp_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_timeserie_tmp_order_by!]

    """filter the rows returned"""
    where: transaction_timeserie_tmp_bool_exp
  ): [transaction_timeserie_tmp!]!

  """
  fetch data from the table: "transaction_timeserie_tmp" using primary key columns
  """
  transaction_timeserie_tmp_by_pk(date: timestamptz!): transaction_timeserie_tmp
}

input search_identity_args {
  name: String
}

"""identities with smith membership"""
type smith {
  """An array relationship"""
  cert_issued(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): [smith_cert!]!

  """An aggregate relationship"""
  cert_issued_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): smith_cert_aggregate!

  """An array relationship"""
  cert_received(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): [smith_cert!]!

  """An aggregate relationship"""
  cert_received_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): smith_cert_aggregate!

  """An object relationship"""
  identity: identity!
  idty_index: Int!
}

"""
aggregated selection of "smith"
"""
type smith_aggregate {
  aggregate: smith_aggregate_fields
  nodes: [smith!]!
}

"""
aggregate fields of "smith"
"""
type smith_aggregate_fields {
  avg: smith_avg_fields
  count(columns: [smith_select_column!], distinct: Boolean): Int!
  max: smith_max_fields
  min: smith_min_fields
  stddev: smith_stddev_fields
  stddev_pop: smith_stddev_pop_fields
  stddev_samp: smith_stddev_samp_fields
  sum: smith_sum_fields
  var_pop: smith_var_pop_fields
  var_samp: smith_var_samp_fields
  variance: smith_variance_fields
}

"""aggregate avg on columns"""
type smith_avg_fields {
  idty_index: Float
}

"""
Boolean expression to filter rows from the table "smith". All fields are combined with a logical 'AND'.
"""
input smith_bool_exp {
  _and: [smith_bool_exp!]
  _not: smith_bool_exp
  _or: [smith_bool_exp!]
  cert_issued: smith_cert_bool_exp
  cert_issued_aggregate: smith_cert_aggregate_bool_exp
  cert_received: smith_cert_bool_exp
  cert_received_aggregate: smith_cert_aggregate_bool_exp
  identity: identity_bool_exp
  idty_index: Int_comparison_exp
}

"""smith certifications"""
type smith_cert {
  created_at: timestamptz!
  created_on: Int!

  """An object relationship"""
  created_on_block: block!

  """An object relationship"""
  issuer: smith!
  issuer_index: Int!

  """An object relationship"""
  receiver: smith!
  receiver_index: Int!
}

"""
aggregated selection of "smith_cert"
"""
type smith_cert_aggregate {
  aggregate: smith_cert_aggregate_fields
  nodes: [smith_cert!]!
}

input smith_cert_aggregate_bool_exp {
  count: smith_cert_aggregate_bool_exp_count
}

input smith_cert_aggregate_bool_exp_count {
  arguments: [smith_cert_select_column!]
  distinct: Boolean
  filter: smith_cert_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "smith_cert"
"""
type smith_cert_aggregate_fields {
  avg: smith_cert_avg_fields
  count(columns: [smith_cert_select_column!], distinct: Boolean): Int!
  max: smith_cert_max_fields
  min: smith_cert_min_fields
  stddev: smith_cert_stddev_fields
  stddev_pop: smith_cert_stddev_pop_fields
  stddev_samp: smith_cert_stddev_samp_fields
  sum: smith_cert_sum_fields
  var_pop: smith_cert_var_pop_fields
  var_samp: smith_cert_var_samp_fields
  variance: smith_cert_variance_fields
}

"""
order by aggregate values of table "smith_cert"
"""
input smith_cert_aggregate_order_by {
  avg: smith_cert_avg_order_by
  count: order_by
  max: smith_cert_max_order_by
  min: smith_cert_min_order_by
  stddev: smith_cert_stddev_order_by
  stddev_pop: smith_cert_stddev_pop_order_by
  stddev_samp: smith_cert_stddev_samp_order_by
  sum: smith_cert_sum_order_by
  var_pop: smith_cert_var_pop_order_by
  var_samp: smith_cert_var_samp_order_by
  variance: smith_cert_variance_order_by
}

"""aggregate avg on columns"""
type smith_cert_avg_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by avg() on columns of table "smith_cert"
"""
input smith_cert_avg_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""
Boolean expression to filter rows from the table "smith_cert". All fields are combined with a logical 'AND'.
"""
input smith_cert_bool_exp {
  _and: [smith_cert_bool_exp!]
  _not: smith_cert_bool_exp
  _or: [smith_cert_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_on: Int_comparison_exp
  created_on_block: block_bool_exp
  issuer: smith_bool_exp
  issuer_index: Int_comparison_exp
  receiver: smith_bool_exp
  receiver_index: Int_comparison_exp
}

"""aggregate max on columns"""
type smith_cert_max_fields {
  created_at: timestamptz
  created_on: Int
  issuer_index: Int
  receiver_index: Int
}

"""
order by max() on columns of table "smith_cert"
"""
input smith_cert_max_order_by {
  created_at: order_by
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate min on columns"""
type smith_cert_min_fields {
  created_at: timestamptz
  created_on: Int
  issuer_index: Int
  receiver_index: Int
}

"""
order by min() on columns of table "smith_cert"
"""
input smith_cert_min_order_by {
  created_at: order_by
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""Ordering options when selecting data from "smith_cert"."""
input smith_cert_order_by {
  created_at: order_by
  created_on: order_by
  created_on_block: block_order_by
  issuer: smith_order_by
  issuer_index: order_by
  receiver: smith_order_by
  receiver_index: order_by
}

"""
select columns of table "smith_cert"
"""
enum smith_cert_select_column {
  """column name"""
  created_at

  """column name"""
  created_on

  """column name"""
  issuer_index

  """column name"""
  receiver_index
}

"""aggregate stddev on columns"""
type smith_cert_stddev_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by stddev() on columns of table "smith_cert"
"""
input smith_cert_stddev_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate stddev_pop on columns"""
type smith_cert_stddev_pop_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by stddev_pop() on columns of table "smith_cert"
"""
input smith_cert_stddev_pop_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate stddev_samp on columns"""
type smith_cert_stddev_samp_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by stddev_samp() on columns of table "smith_cert"
"""
input smith_cert_stddev_samp_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""
Streaming cursor of the table "smith_cert"
"""
input smith_cert_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: smith_cert_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input smith_cert_stream_cursor_value_input {
  created_at: timestamptz
  created_on: Int
  issuer_index: Int
  receiver_index: Int
}

"""aggregate sum on columns"""
type smith_cert_sum_fields {
  created_on: Int
  issuer_index: Int
  receiver_index: Int
}

"""
order by sum() on columns of table "smith_cert"
"""
input smith_cert_sum_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate var_pop on columns"""
type smith_cert_var_pop_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by var_pop() on columns of table "smith_cert"
"""
input smith_cert_var_pop_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate var_samp on columns"""
type smith_cert_var_samp_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by var_samp() on columns of table "smith_cert"
"""
input smith_cert_var_samp_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate variance on columns"""
type smith_cert_variance_fields {
  created_on: Float
  issuer_index: Float
  receiver_index: Float
}

"""
order by variance() on columns of table "smith_cert"
"""
input smith_cert_variance_order_by {
  created_on: order_by
  issuer_index: order_by
  receiver_index: order_by
}

"""aggregate max on columns"""
type smith_max_fields {
  idty_index: Int
}

"""aggregate min on columns"""
type smith_min_fields {
  idty_index: Int
}

"""Ordering options when selecting data from "smith"."""
input smith_order_by {
  cert_issued_aggregate: smith_cert_aggregate_order_by
  cert_received_aggregate: smith_cert_aggregate_order_by
  identity: identity_order_by
  idty_index: order_by
}

"""
select columns of table "smith"
"""
enum smith_select_column {
  """column name"""
  idty_index
}

"""aggregate stddev on columns"""
type smith_stddev_fields {
  idty_index: Float
}

"""aggregate stddev_pop on columns"""
type smith_stddev_pop_fields {
  idty_index: Float
}

"""aggregate stddev_samp on columns"""
type smith_stddev_samp_fields {
  idty_index: Float
}

"""
Streaming cursor of the table "smith"
"""
input smith_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: smith_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input smith_stream_cursor_value_input {
  idty_index: Int
}

"""aggregate sum on columns"""
type smith_sum_fields {
  idty_index: Int
}

"""aggregate var_pop on columns"""
type smith_var_pop_fields {
  idty_index: Float
}

"""aggregate var_samp on columns"""
type smith_var_samp_fields {
  idty_index: Float
}

"""aggregate variance on columns"""
type smith_variance_fields {
  idty_index: Float
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "account"
  """
  account(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch aggregated fields from the table: "account"
  """
  account_aggregate(
    """distinct select on columns"""
    distinct_on: [account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_order_by!]

    """filter the rows returned"""
    where: account_bool_exp
  ): account_aggregate!

  """fetch data from the table: "account" using primary key columns"""
  account_by_pk(
    """Pubkey of the account."""
    pubkey: String!
  ): account

  """
  fetch data from the table in a streaming manner: "account"
  """
  account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_stream_cursor_input]!

    """filter the rows returned"""
    where: account_bool_exp
  ): [account!]!

  """
  fetch data from the table: "block"
  """
  block(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch aggregated fields from the table: "block"
  """
  block_aggregate(
    """distinct select on columns"""
    distinct_on: [block_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [block_order_by!]

    """filter the rows returned"""
    where: block_bool_exp
  ): block_aggregate!

  """fetch data from the table: "block" using primary key columns"""
  block_by_pk(
    """Number of the block in substrate."""
    number: Int!
  ): block

  """
  fetch data from the table in a streaming manner: "block"
  """
  block_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [block_stream_cursor_input]!

    """filter the rows returned"""
    where: block_bool_exp
  ): [block!]!

  """
  fetch data from the table: "certification"
  """
  certification(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): [certification!]!

  """
  fetch aggregated fields from the table: "certification"
  """
  certification_aggregate(
    """distinct select on columns"""
    distinct_on: [certification_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [certification_order_by!]

    """filter the rows returned"""
    where: certification_bool_exp
  ): certification_aggregate!

  """fetch data from the table: "certification" using primary key columns"""
  certification_by_pk(
    """Block number where certification was created."""
    created_on: Int!

    """Index of issuer"""
    issuer_index: Int!

    """Index of receiver"""
    receiver_index: Int!
  ): certification

  """
  fetch data from the table in a streaming manner: "certification"
  """
  certification_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [certification_stream_cursor_input]!

    """filter the rows returned"""
    where: certification_bool_exp
  ): [certification!]!

  """
  fetch data from the table: "identity"
  """
  identity(
    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): [identity!]!

  """
  fetch aggregated fields from the table: "identity"
  """
  identity_aggregate(
    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): identity_aggregate!

  """fetch data from the table: "identity" using primary key columns"""
  identity_by_pk(index: Int!): identity

  """
  fetch data from the table in a streaming manner: "identity"
  """
  identity_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [identity_stream_cursor_input]!

    """filter the rows returned"""
    where: identity_bool_exp
  ): [identity!]!

  """
  fetch data from the table: "parameters"
  """
  parameters(
    """distinct select on columns"""
    distinct_on: [parameters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [parameters_order_by!]

    """filter the rows returned"""
    where: parameters_bool_exp
  ): [parameters!]!

  """fetch data from the table: "parameters" using primary key columns"""
  parameters_by_pk(key: String!): parameters

  """
  fetch data from the table in a streaming manner: "parameters"
  """
  parameters_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [parameters_stream_cursor_input]!

    """filter the rows returned"""
    where: parameters_bool_exp
  ): [parameters!]!

  """
  execute function "search_identity" which returns "identity"
  """
  search_identity(
    """
    input parameters for function "search_identity"
    """
    args: search_identity_args!

    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): [identity!]!

  """
  execute function "search_identity" and query aggregates on result of table type "identity"
  """
  search_identity_aggregate(
    """
    input parameters for function "search_identity_aggregate"
    """
    args: search_identity_args!

    """distinct select on columns"""
    distinct_on: [identity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [identity_order_by!]

    """filter the rows returned"""
    where: identity_bool_exp
  ): identity_aggregate!

  """
  fetch data from the table: "smith"
  """
  smith(
    """distinct select on columns"""
    distinct_on: [smith_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_order_by!]

    """filter the rows returned"""
    where: smith_bool_exp
  ): [smith!]!

  """
  fetch aggregated fields from the table: "smith"
  """
  smith_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_order_by!]

    """filter the rows returned"""
    where: smith_bool_exp
  ): smith_aggregate!

  """fetch data from the table: "smith" using primary key columns"""
  smith_by_pk(idty_index: Int!): smith

  """
  fetch data from the table: "smith_cert"
  """
  smith_cert(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): [smith_cert!]!

  """
  fetch aggregated fields from the table: "smith_cert"
  """
  smith_cert_aggregate(
    """distinct select on columns"""
    distinct_on: [smith_cert_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [smith_cert_order_by!]

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): smith_cert_aggregate!

  """fetch data from the table: "smith_cert" using primary key columns"""
  smith_cert_by_pk(created_on: Int!, issuer_index: Int!, receiver_index: Int!): smith_cert

  """
  fetch data from the table in a streaming manner: "smith_cert"
  """
  smith_cert_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [smith_cert_stream_cursor_input]!

    """filter the rows returned"""
    where: smith_cert_bool_exp
  ): [smith_cert!]!

  """
  fetch data from the table in a streaming manner: "smith"
  """
  smith_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [smith_stream_cursor_input]!

    """filter the rows returned"""
    where: smith_bool_exp
  ): [smith!]!

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(
    """
    Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
    """
    id: Int!
  ): transaction

  """
  fetch data from the table in a streaming manner: "transaction"
  """
  transaction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transaction_stream_cursor_input]!

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  execute function "transaction_timeserie" which returns "transaction_timeserie_tmp"
  """
  transaction_timeserie(
    """
    input parameters for function "transaction_timeserie"
    """
    args: transaction_timeserie_args!

    """distinct select on columns"""
    distinct_on: [transaction_timeserie_tmp_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_timeserie_tmp_order_by!]

    """filter the rows returned"""
    where: transaction_timeserie_tmp_bool_exp
  ): [transaction_timeserie_tmp!]!

  """
  fetch data from the table: "transaction_timeserie_tmp"
  """
  transaction_timeserie_tmp(
    """distinct select on columns"""
    distinct_on: [transaction_timeserie_tmp_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_timeserie_tmp_order_by!]

    """filter the rows returned"""
    where: transaction_timeserie_tmp_bool_exp
  ): [transaction_timeserie_tmp!]!

  """
  fetch data from the table: "transaction_timeserie_tmp" using primary key columns
  """
  transaction_timeserie_tmp_by_pk(date: timestamptz!): transaction_timeserie_tmp

  """
  fetch data from the table in a streaming manner: "transaction_timeserie_tmp"
  """
  transaction_timeserie_tmp_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transaction_timeserie_tmp_stream_cursor_input]!

    """filter the rows returned"""
    where: transaction_timeserie_tmp_bool_exp
  ): [transaction_timeserie_tmp!]!
}

scalar time_period

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Table of transactions."""
type transaction {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float!
  comment: String
  created_at: timestamptz!

  """Block number where transaction was created."""
  created_on: Int!

  """An object relationship"""
  created_on_block: block!

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Int!

  """An object relationship"""
  issuer: account!
  issuer_pubkey: String!

  """An object relationship"""
  receiver: account!
  receiver_pubkey: String!
}

"""
aggregated selection of "transaction"
"""
type transaction_aggregate {
  aggregate: transaction_aggregate_fields
  nodes: [transaction!]!
}

input transaction_aggregate_bool_exp {
  count: transaction_aggregate_bool_exp_count
}

input transaction_aggregate_bool_exp_count {
  arguments: [transaction_select_column!]
  distinct: Boolean
  filter: transaction_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transaction"
"""
type transaction_aggregate_fields {
  avg: transaction_avg_fields
  count(columns: [transaction_select_column!], distinct: Boolean): Int!
  max: transaction_max_fields
  min: transaction_min_fields
  stddev: transaction_stddev_fields
  stddev_pop: transaction_stddev_pop_fields
  stddev_samp: transaction_stddev_samp_fields
  sum: transaction_sum_fields
  var_pop: transaction_var_pop_fields
  var_samp: transaction_var_samp_fields
  variance: transaction_variance_fields
}

"""
order by aggregate values of table "transaction"
"""
input transaction_aggregate_order_by {
  avg: transaction_avg_order_by
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
  stddev: transaction_stddev_order_by
  stddev_pop: transaction_stddev_pop_order_by
  stddev_samp: transaction_stddev_samp_order_by
  sum: transaction_sum_order_by
  var_pop: transaction_var_pop_order_by
  var_samp: transaction_var_samp_order_by
  variance: transaction_variance_order_by
}

"""aggregate avg on columns"""
type transaction_avg_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by avg() on columns of table "transaction"
"""
input transaction_avg_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""
Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
"""
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  amount: Float_comparison_exp
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_on: Int_comparison_exp
  created_on_block: block_bool_exp
  id: Int_comparison_exp
  issuer: account_bool_exp
  issuer_pubkey: String_comparison_exp
  receiver: account_bool_exp
  receiver_pubkey: String_comparison_exp
}

"""aggregate max on columns"""
type transaction_max_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float
  comment: String
  created_at: timestamptz

  """Block number where transaction was created."""
  created_on: Int

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Int
  issuer_pubkey: String
  receiver_pubkey: String
}

"""
order by max() on columns of table "transaction"
"""
input transaction_max_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by
  comment: order_by
  created_at: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
  issuer_pubkey: order_by
  receiver_pubkey: order_by
}

"""aggregate min on columns"""
type transaction_min_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float
  comment: String
  created_at: timestamptz

  """Block number where transaction was created."""
  created_on: Int

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Int
  issuer_pubkey: String
  receiver_pubkey: String
}

"""
order by min() on columns of table "transaction"
"""
input transaction_min_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by
  comment: order_by
  created_at: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
  issuer_pubkey: order_by
  receiver_pubkey: order_by
}

"""Ordering options when selecting data from "transaction"."""
input transaction_order_by {
  amount: order_by
  comment: order_by
  created_at: order_by
  created_on: order_by
  created_on_block: block_order_by
  id: order_by
  issuer: account_order_by
  issuer_pubkey: order_by
  receiver: account_order_by
  receiver_pubkey: order_by
}

"""
select columns of table "transaction"
"""
enum transaction_select_column {
  """column name"""
  amount

  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  created_on

  """column name"""
  id

  """column name"""
  issuer_pubkey

  """column name"""
  receiver_pubkey
}

"""aggregate stddev on columns"""
type transaction_stddev_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by stddev() on columns of table "transaction"
"""
input transaction_stddev_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""aggregate stddev_pop on columns"""
type transaction_stddev_pop_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by stddev_pop() on columns of table "transaction"
"""
input transaction_stddev_pop_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""aggregate stddev_samp on columns"""
type transaction_stddev_samp_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by stddev_samp() on columns of table "transaction"
"""
input transaction_stddev_samp_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""
Streaming cursor of the table "transaction"
"""
input transaction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transaction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transaction_stream_cursor_value_input {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float
  comment: String
  created_at: timestamptz

  """Block number where transaction was created."""
  created_on: Int

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Int
  issuer_pubkey: String
  receiver_pubkey: String
}

"""aggregate sum on columns"""
type transaction_sum_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Int

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Int
}

"""
order by sum() on columns of table "transaction"
"""
input transaction_sum_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

input transaction_timeserie_args {
  from: date
  issuer_pk: String
  period: time_period
  receiver_pk: String
  to: date
}

"""This table is empty. It's only for Hasura."""
type transaction_timeserie_tmp {
  amount: Float!
  date: timestamptz!
}

"""
Boolean expression to filter rows from the table "transaction_timeserie_tmp". All fields are combined with a logical 'AND'.
"""
input transaction_timeserie_tmp_bool_exp {
  _and: [transaction_timeserie_tmp_bool_exp!]
  _not: transaction_timeserie_tmp_bool_exp
  _or: [transaction_timeserie_tmp_bool_exp!]
  amount: Float_comparison_exp
  date: timestamptz_comparison_exp
}

"""Ordering options when selecting data from "transaction_timeserie_tmp"."""
input transaction_timeserie_tmp_order_by {
  amount: order_by
  date: order_by
}

"""
select columns of table "transaction_timeserie_tmp"
"""
enum transaction_timeserie_tmp_select_column {
  """column name"""
  amount

  """column name"""
  date
}

"""
Streaming cursor of the table "transaction_timeserie_tmp"
"""
input transaction_timeserie_tmp_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transaction_timeserie_tmp_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transaction_timeserie_tmp_stream_cursor_value_input {
  amount: Float
  date: timestamptz
}

"""aggregate var_pop on columns"""
type transaction_var_pop_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by var_pop() on columns of table "transaction"
"""
input transaction_var_pop_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""aggregate var_samp on columns"""
type transaction_var_samp_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by var_samp() on columns of table "transaction"
"""
input transaction_var_samp_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

"""aggregate variance on columns"""
type transaction_variance_fields {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: Float

  """Block number where transaction was created."""
  created_on: Float

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: Float
}

"""
order by variance() on columns of table "transaction"
"""
input transaction_variance_order_by {
  """Amount of the transaction. 100 units = 1 Ğ1."""
  amount: order_by

  """Block number where transaction was created."""
  created_on: order_by

  """
  Primary Key `id` is used for postgreSQL and Hasura relationship, not related to any value in substrate.
  """
  id: order_by
}

